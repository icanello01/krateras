# -*- coding: utf-8 -*-
"""krateras.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MHVfh8aR8VeZwbV2wJfufL2ZNX9Hu1wb
"""

# -*- coding: utf-8 -*-
"""
Krateras üöÄ‚ú®üîí: O Especialista Rob√≥tico de Den√∫ncia de Buracos (v3.2 - Maximum Secure Colab Edition)

Ol√°! Krateras v3.2 entrando em √≥rbita! A seguran√ßa dos seus dados √© minha prioridade m√°xima.
Agora, eu vou tentar obter AMBAS as suas chaves de API (Gemini e Geocoding) dos Segredos
do Google Colab, mantendo-as TOTALMENTE fora do c√≥digo fonte vis√≠vel!

Fui criado com o que h√° de mais avan√ßado em Programa√ß√£o, IA, Design Inteligente,
Matem√°tica (ainda essencial!) e L√≥gica Inabal√°vel. Com acesso seguro √†s APIs, sou impar√°vel.

Vamos juntos consertar essas ruas! Iniciando varredura de chaves...
"""

import sys
import subprocess
import json
import os
import time
from typing import Dict, Any, Optional
import re
import textwrap

# --- Tentar importar google.colab.userdata para acessar Segredos ---
# Isso precisa ser feito no in√≠cio para verificarmos a disponibilidade do ambiente.
try:
    from google.colab import userdata
    COLAB_SECRETS_AVAILABLE = True
    print("‚úÖ M√≥dulo google.colab.userdata dispon√≠vel. Ambiente Colab detectado. Tentarei usar Segredos.")
except ImportError:
    COLAB_SECRETS_AVAILABLE = False
    print("‚ö†Ô∏è M√≥dulo google.colab.userdata n√£o dispon√≠vel. N√£o estou rodando no Colab ou acesso aos Segredos est√° restrito.")
    print("Solicitarei as chaves de API manualmente via input.")


# --- ‚öôÔ∏è Configura√ß√£o Inicial: Depend√™ncias ---
# Garante que temos as ferramentas certas instaladas.

required_libraries: list[str] = ['requests', 'google-generativeai'] # Requests para ViaCEP e Geocoding API, Gemini para IA

def install_dependencies(libraries: list[str]):
    """Verifica e instala bibliotecas necess√°rias no ambiente Colab."""
    print("‚ú® Krateras v3.2 Inicializando seus sistemas...")
    print("üîß Realizando varredura de componentes essenciais e instalando ferramentas...")
    for lib in libraries:
        try:
            __import__(lib)
            # print(f"'{lib}' detectado. Componente online.") # Comentado para output mais limpo
        except ImportError:
            print(f"üõ∞Ô∏è Ferramenta '{lib}' n√£o encontrada. Baixando e instalando do meu reposit√≥rio central...")
            try:
                # Usamos Popen para evitar travar e capturar output de instala√ß√£o
                process = subprocess.Popen([sys.executable, "-m", "pip", "install", lib], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdout, stderr = process.communicate()
                if process.returncode != 0:
                     raise subprocess.CalledProcessError(process.returncode, process.args, output=stdout, stderr=stderr)
                print(f"'{lib}' instalado com sucesso. Montagem completa!")
            except subprocess.CalledProcessError as e:
                print(f"‚ùå ERRO CR√çTICO no Hardware: Falha na instala√ß√£o do componente '{lib}'.")
                print("Meu sistema est√° comprometido sem esta ferramenta. Tente instalar manualmente no Colab:")
                print(f"!pip install {lib}")
                print(f"Detalhes t√©cnicos do erro:\n{e.stderr.decode()}")
                sys.exit(1)

install_dependencies(required_libraries)

# Importa as bibliotecas ap√≥s garantir que est√£o instaladas
import requests
import google.generativeai as genai

# --- üîë Gerenciamento de Chaves Secretas (APIs) ---
# Prioriza Segredos do Colab para AMBAS as chaves.

def get_api_keys() -> tuple[Optional[str], Optional[str]]:
    """
    Tenta obter as chaves de API do Google Gemini e Google Maps Geocoding de Segredos do Colab.
    Solicita manualmente se n√£o encontradas ou se n√£o est√° no ambiente Colab.
    """
    print("\n--- üîë Inserindo Chaves de Acesso Seguras (Energia Secreta para os Rob√¥s!) ---")
    print("Vou tentar carregar suas chaves dos Segredos do Colab para m√°xima seguran√ßa.")
    print("Certifique-se de ter os segredos 'GOOGLE_API_KEY' (para Gemini) e 'geocoding_api_key' (para Geocoding) configurados.")


    gemini_key: Optional[str] = None
    geocoding_key: Optional[str] = None

    # --- Tentar obter Chave Gemini de Segredos ---
    print("\n1. Chave Google AI Studio/Vertex AI (Gemini):")
    if COLAB_SECRETS_AVAILABLE:
        print("üíæ Tentando obter a chave 'GOOGLE_API_KEY' dos Segredos do Colab...")
        try:
            gemini_key = userdata.get('GOOGLE_API_KEY')
            if gemini_key:
                print("‚úÖ Chave 'GOOGLE_API_KEY' encontrada nos Segredos do Colab!")
            else:
                print("‚ö†Ô∏è Segredo 'GOOGLE_API_KEY' n√£o encontrado nos Segredos do Colab.")
        except Exception as e:
            print(f"‚ùå Erro ao tentar acessar Segredo 'GOOGLE_API_KEY': {e}.")
            gemini_key = None # Garante que a chave seja None em caso de erro
    else:
        print("‚ÑπÔ∏è Segredos do Colab n√£o dispon√≠veis. Pular verifica√ß√£o de Segredo para Gemini.")


    # --- Tentar obter Chave Geocoding de Segredos ---
    print("\n2. Chave Google Cloud Platform (Geocoding API):")
    if COLAB_SECRETS_AVAILABLE:
        print("üíæ Tentando obter a chave 'geocoding_api_key' dos Segredos do Colab...")
        try:
            geocoding_key = userdata.get('geocoding_api_key')
            if geocoding_key:
                print("‚úÖ Chave 'geocoding_api_key' encontrada nos Segredos do Colab!")
            else:
                 print("‚ö†Ô∏è Segredo 'geocoding_api_key' n√£o encontrado nos Segredos do Colab.")
        except Exception as e:
            print(f"‚ùå Erro ao tentar acessar Segredo 'geocoding_api_key': {e}.")
            geocoding_key = None # Garante que a chave seja None em caso de erro
    else:
        print("‚ÑπÔ∏è Segredos do Colab n√£o dispon√≠veis. Pular verifica√ß√£o de Segredo para Geocoding.")


    # --- Fallback para Input Manual se as chaves n√£o foram encontradas nos Segredos ---

    if not gemini_key:
        print("\n‚û°Ô∏è Por favor, insira sua Chave de API do Google Gemini (se n√£o configurou o segredo ou para usar outra chave).")
        print("   (Ou apenas Enter para pular - An√°lise IA ser√° desabilitada).")
        gemini_key = input("Sua Chave de API do Google Gemini: ").strip()
        if not gemini_key:
            print("‚ö†Ô∏è Chave Gemini n√£o fornecida. An√°lise de IA do Gemini desabilitada.")

    if not geocoding_key:
        print("\n‚û°Ô∏è Por favor, insira sua Chave de API do Google Maps Geocoding (se n√£o configurou o segredo ou para usar outra chave).")
        print("   (Ou apenas Enter se n√£o tiver/n√£o quiser usar - Geocodifica√ß√£o autom√°tica desabilitada).")
        print("   ‚ùó Lembre-se que a API Geocoding PODE gerar custos. Ative-a no Google Cloud.")
        geocoding_key = input("Sua Chave de API do Google Maps Geocoding: ").strip()
        if not geocoding_key:
            print("‚ö†Ô∏è Chave de API de Geocoding n√£o fornecida. Geocodifica√ß√£o autom√°tica desabilitada.")


    return gemini_key, geocoding_key

def init_gemini(api_key: str) -> Optional[genai.GenerativeModel]:
    """Inicializa o modelo Google Gemini."""
    if not api_key:
        print("\n‚ö†Ô∏è AVISO: Chave de API do Gemini n√£o fornecida. As funcionalidades de IA do Gemini est√£o desabilitadas.")
        return None
    try:
        genai.configure(api_key=api_key)
        # Buscar modelos que suportam gera√ß√£o de conte√∫do de texto
        available_models = [m.name for m in genai.list_models() if 'generateContent' in m.supported_generation_methods]

        if not available_models:
             print("\n‚ùå ERRO na F√°brica de Modelos: Nenhum modelo de texto Gemini compat√≠vel encontrado na sua conta.")
             return None

        preferred_models: list[str] = ['gemini-1.5-flash-latest', 'gemini-1.0-pro', 'gemini-pro']
        model_name: Optional[str] = None
        for pref_model in preferred_models:
            if f'models/{pref_model}' in available_models:
                model_name = pref_model
                break
            if pref_model in available_models: # Verifica sem o prefixo 'models/'
                 model_name = pref_model
                 break

        if not model_name:
            model_name = available_models[0].replace('models/', '')
            print(f"‚ö†Ô∏è AVISO: Modelos Gemini preferenciais n√£o encontrados. Usando fallback: '{model_name}'. Pode ter menos funcionalidades.")

        model = genai.GenerativeModel(model_name)
        # Opcional: testar uma chamada b√°sica para verificar se a API est√° funcionando
        # model.generate_content("Ping")
        print(f"‚úÖ Conex√£o com Google Gemini estabelecida usando modelo '{model_name}'. A IA est√° online e pensativa!")
        return model
    except Exception as e:
        print(f"\n‚ùå ERRO no Painel de Controle Gemini: Falha na inicializa√ß√£o do Google Gemini. Verifique sua chave e status do servi√ßo.")
        print(f"Detalhes t√©cnicos do erro: {e}")
        return None

def geocodificar_endereco(rua: str, numero: str, cidade: str, estado: str, api_key: str) -> Dict[str, Any]:
    """Tenta obter coordenadas geogr√°ficas e link Google Maps via Google Maps Geocoding API."""
    if not api_key:
        return {"erro": "Chave de API de Geocodifica√ß√£o n√£o fornecida."}
    # Adicionado valida√ß√£o b√°sica para garantir que os campos essenciais n√£o estejam vazios
    if not rua or not numero or not cidade or not estado:
         return {"erro": "Dados de endere√ßo insuficientes (requer rua, n√∫mero, cidade, estado) para geocodificar."}

    address = f"{rua}, {numero}, {cidade}, {estado}"
    # Use requests.utils.quote para garantir que o endere√ßo seja formatado corretamente na URL
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={requests.utils.quote(address)}&key={api_key}"

    print(f"‚è≥ Tentando localizar '{address}' no mapa global via Geocoding API...")
    try:
        response = requests.get(url, timeout=15)
        response.raise_for_status()
        data = response.json()

        if data['status'] != 'OK':
            status = data.get('status', 'STATUS DESCONHECIDO')
            error_msg = data.get('error_message', 'Sem mensagem adicional.')
            return {"erro": f"Geocodifica√ß√£o falhou. Status: {status}. Mensagem: {error_msg}"}
        if not data['results']:
             return {"erro": "Geocodifica√ß√£o falhou. Nenhum local exato encontrado para o endere√ßo fornecido."}

        # Pegar o primeiro resultado
        location = data['results'][0]['geometry']['location']
        lat = location['lat']
        lng = location['lng']
        formatted_address = data['results'][0].get('formatted_address', address)

        return {
            "latitude": lat,
            "longitude": lng,
            "endereco_formatado_api": formatted_address, # Nome mais claro
            "google_maps_link_gerado": f"https://www.google.com/maps/search/?api=1&query={lat},{lng}"
        }
    except requests.exceptions.Timeout:
         return {"erro": f"Tempo limite excedido ({15}s) ao tentar geocodificar: {address}"}
    except requests.exceptions.RequestException as e:
        return {"erro": f"Erro na comunica√ß√£o com a API de Geocodifica√ß√£o: {address}. Detalhes: {e}"}
    except Exception as e:
        return {"erro": f"Ocorreu um erro inesperado durante a geocodifica√ß√£o: {address}. Detalhes: {e}"}


# --- ü§ñ Fun√ß√µes de Coleta de Dados Inteligente ---
# Coletamos as informa√ß√µes, com valida√ß√µes e fluxo aprimorados.

def coletar_dados_denunciante() -> Dict[str, Any]:
    """Coleta informa√ß√µes do usu√°rio denunciante com um toque amig√°vel."""
    print("\n--- üë§ Dados do Her√≥i/Hero√≠na da Vez! ---")
    nome = input("Seu nome completo: ").strip()
    while not nome:
        print("‚ùó Nome n√£o pode ser um mist√©rio. Quem √© voc√™ na fila do p√£o da cidadania?")
        nome = input("Seu nome completo: ").strip()

    idade_str = input("Sua idade (aproximada, se preferir, sem press√£o üòâ): ").strip()
    while not idade_str.isdigit() or int(idade_str) <= 0 or int(idade_str) > 120:
        print("‚ùó Idade inv√°lida. N√£o se preocupe, rob√¥s n√£o julgam (ainda)!")
        idade_str = input("Sua idade: ").strip()
    idade = int(idade_str)

    # Este √© a CIDADE DE RESID√äNCIA DO DENUNCIANTE
    cidade = input("Em qual cidade voc√™ reside?: ").strip()
    while not cidade:
        print("‚ùó Cidade de resid√™ncia n√£o pode ficar vazia. Precisamos saber sua base de opera√ß√µes!")
        cidade = input("Em qual cidade voc√™ reside?: ").strip()

    print(f"Ol√°, {nome}! Sua contribui√ß√£o √© super valiosa! üí™")
    return {
        "nome": nome,
        "idade": idade,
        "cidade_residencia": cidade # Nome da chave mais expl√≠cito
    }

def buscar_cep(cep: str) -> Dict[str, Any]:
    """Consulta a API ViaCEP para obter dados de endere√ßo com tratamento de erros."""
    cep_limpo = cep.replace("-", "").replace(".", "").strip()
    if len(cep_limpo) != 8 or not cep_limpo.isdigit():
        return {"erro": "Formato de CEP inv√°lido. Precisa de 8 d√≠gitos, amig√£o!"}

    url = f"https://viacep.com.br/ws/{cep_limpo}/json/"
    print(f"‚è≥ Interrogando o ViaCEP para o CEP '{cep_limpo}'...")
    try:
        response = requests.get(url, timeout=15) # Aumenta o timeout um pouco
        response.raise_for_status() # Lan√ßa exce√ß√£o para status de erro (4xx ou 5xx)
        data = response.json()
        if 'erro' in data and data['erro'] is True:
            return {"erro": f"CEP '{cep_limpo}' n√£o encontrado no ViaCEP. Ele se escondeu! üßê"}
        # Verificar se os campos essenciais est√£o presentes
        if not data.get('logradouro') or not data.get('localidade') or not data.get('uf'):
             return {"erro": f"CEP '{cep_limpo}' encontrado, mas os dados de endere√ßo est√£o incompletos. O ViaCEP s√≥ contou parte da hist√≥ria!"}
        return data
    except requests.exceptions.Timeout:
         return {"erro": f"Tempo limite excedido ({15}s) ao buscar o CEP '{cep_limpo}'. O ViaCEP n√£o responde! üò¥"}
    except requests.exceptions.RequestException as e:
        return {"erro": f"Erro na comunica√ß√£o com o ViaCEP para o CEP '{cep_limpo}': {e}. Problemas na linha!"}
    except Exception as e:
         return {"erro": f"Ocorreu um erro inesperado ao buscar o CEP '{cep_limpo}': {e}. Isso n√£o estava nos meus manuais!"}


def coletar_dados_buraco(geocoding_api_key: Optional[str]) -> Dict[str, Any]:
    """Coleta informa√ß√µes detalhadas sobre o buraco, com fluxo aprimorado, geocodifica√ß√£o condicional e IA."""
    print("\n--- üöß Detalhes do Buraco (Nosso Alvo!) ---")

    endereco: Dict[str, str] = {} # Dados b√°sicos de rua, bairro, cidade, estado do buraco
    cep_informado: str = "" # Armazena o CEP se o usu√°rio o forneceu
    rua_coletada_com_sucesso: bool = False

    while not rua_coletada_com_sucesso:
        opcao_localizacao = input("Como identificar a rua do buraco? (1 - Digitar nome manualmente | 2 - Buscar por CEP): ").strip()

        if opcao_localizacao == '1':
            endereco['rua'] = input("Nome completo da rua: ").strip()
            while not endereco.get('rua'):
                 print("‚ùó O nome da rua √© o m√≠nimo que precisamos! Onde est√° o buraco?")
                 endereco['rua'] = input("Nome completo da rua: ").strip()
            # Este √© a CIDADE DO BURACO (quando inserida manualmente)
            endereco['cidade_buraco'] = input("Cidade onde est√° o buraco: ").strip()
            while not endereco.get('cidade_buraco'):
                 print("‚ùó Precisamos da cidade onde est√° o buraco.")
                 endereco['cidade_buraco'] = input("Cidade onde est√° o buraco: ").strip()
            endereco['estado_buraco'] = input("Estado (UF) onde est√° o buraco: ").strip()
            while not endereco.get('estado_buraco'):
                 print("‚ùó E o estado do buraco tamb√©m √© importante!")
                 endereco['estado_buraco'] = input("Estado (UF) onde est√° o buraco: ").strip()
            endereco['bairro'] = input("Bairro onde est√° o buraco (opcional): ").strip()
            rua_coletada_com_sucesso = True
        elif opcao_localizacao == '2':
            print("--- Busca por CEP ---")
            print("Digite o CEP do local do buraco (ou 'm' para voltar e digitar a rua manualmente).")
            while True: # Loop interno para tentativas de CEP
                cep_input = input("Digite o CEP ou 'm': ").strip().lower()

                if cep_input == 'm':
                    print("Ok. Alternando para entrada manual da rua.")
                    break # Sai do loop interno de CEP
                if not cep_input:
                     print("‚ùó Entrada n√£o pode ser vazia. Forne√ßa um CEP v√°lido ou 'm'!")
                     continue # Pede CEP ou 'm' novamente

                dados_cep = buscar_cep(cep_input)

                if 'erro' in dados_cep:
                    print(f"‚ùå Falha na busca por CEP: {dados_cep['erro']}")
                    continue # Loop interno continua
                else: # CEP encontrado com sucesso
                    cep_informado = cep_input
                    print("\n--- ‚úÖ Endere√ßo Encontrado (ViaCEP) ---")
                    print(f"Rua: {dados_cep.get('logradouro', 'N√£o informado')}")
                    print(f"Bairro: {dados_cep.get('bairro', 'N√£o informado')}")
                    print(f"Cidade: {dados_cep.get('localidade', 'N√£o informado')}") # localidade do CEP
                    print(f"Estado: {dados_cep.get('uf', 'N√£o informado')}") # uf do CEP
                    print(f"CEP: {cep_informado}")
                    print("--------------------------------------")

                    confirmacao = input("As informa√ß√µes acima parecem corretas? (s/n, padr√£o 's'): ").strip().lower()
                    if confirmacao == 's' or confirmacao == '':
                        endereco['rua'] = dados_cep.get('logradouro', '')
                        endereco['bairro'] = dados_cep.get('bairro', '')
                        endereco['cidade_buraco'] = dados_cep.get('localidade', '') # Cidade do Buraco via CEP
                        endereco['estado_buraco'] = dados_cep.get('uf', '')     # Estado do Buraco via CEP
                        print("‚úÖ Endere√ßo confirmado. Precis√£o rob√≥tica aprovada!")
                    else:
                        print("‚ùó Endere√ßo do CEP n√£o confirmado. Vamos corrigir manualmente.")
                        endereco['rua'] = input("Nome da rua CORRETA: ").strip()
                        while not endereco.get('rua'):
                             print("‚ùó Nome da rua √© essencial. Qual o nome CORRETO?")
                             endereco['rua'] = input("Nome da rua CORRETA: ").strip()
                        endereco['bairro'] = input("Bairro CORRETO (opcional): ").strip()
                         # Usa cidade/estado do CEP como padr√£o se n√£o informado manualmente, para facilitar
                        endereco['cidade_buraco'] = input(f"Cidade CORRETA (Padr√£o: {dados_cep.get('localidade', 'N√£o informado')}): ").strip() or dados_cep.get('localidade', '')
                        while not endereco.get('cidade_buraco'): # Garante que a cidade n√£o fique vazia
                            print("‚ùó Cidade do buraco n√£o pode ser vazia. Digite a cidade CORRETA.")
                            endereco['cidade_buraco'] = input("Cidade CORRETA: ").strip()

                        endereco['estado_buraco'] = input(f"Estado CORRETO (UF) (Padr√£o: {dados_cep.get('uf', 'N√£o informado')}): ").strip() or dados_cep.get('uf', '')
                        while not endereco.get('estado_buraco'): # Garante que o estado n√£o fique vazio
                             print("‚ùó Estado do buraco √© obrigat√≥rio. Digite o Estado CORRETO.")
                             endereco['estado_buraco'] = input("Estado CORRETO (UF): ").strip()

                        print("‚úÖ Endere√ßo corrigido manualmente. Flexibilidade √© meu forte!")

                    rua_coletada_com_sucesso = True # Sai do loop principal de rua
                    break # Sai do loop interno de CEP
            # Se o loop interno terminou por 'm', o loop externo continua.
        else:
            print("‚ùó Op√ß√£o inv√°lida. Escolha 1 ou 2. Minha l√≥gica s√≥ entende isso por enquanto!")

    # --- Coletar N√∫mero Pr√≥ximo e Lado da Rua ---
    numero_proximo = input("N√∫mero do im√≥vel mais pr√≥ximo ou ponto de refer√™ncia (Ex: 'Em frente ao 123', 'Esquina c/ Rua X'. ESSENCIAL para precis√£o!): ").strip()
    while not numero_proximo:
        print("‚ùó O n√∫mero pr√≥ximo/refer√™ncia √© VITAL para localizar o buraco precisamente. Por favor, informe!")
        numero_proximo = input("N√∫mero do im√≥vel mais pr√≥ximo ou ponto de refer√™ncia: ").strip()

    lado_rua = input("Lado da rua onde est√° o buraco (Ex: 'lado par', 'lado √≠mpar', 'lado direito', 'lado esquerdo'. Ajuda a identificar o ponto exato): ").strip()
    while not lado_rua:
         print("‚ùó Saber o lado da rua afina a busca no mapa. Qual √© o lado?")
         lado_rua = input("Lado da rua: ").strip()

    # --- üìç Coleta de Localiza√ß√£o Exata (Geocodifica√ß√£o com Link Google Maps ou Manual) ---
    print("\n--- üìç ONDE EXATAMENTE EST√Å O BURACO? (Miss√£o de Precis√£o!) ---")
    print("Agora, a localiza√ß√£o exata para que o time de reparo v√° DIRETO ao ponto!")
    print("Lembre-se: N√£o acesso seu GPS (estou na nuvem!).")

    localizacao_exata_processada: Dict[str, Any] = {"tipo": "N√£o informada"} # Dicion√°rio para armazenar a localiza√ß√£o final processada
    tentou_geocodificar: bool = False
    geocodificacao_sucesso: bool = False
    motivo_falha_geo: str = ""

    # Condi√ß√£o para tentar geocodificar: Tem chave de API E tem Rua, N√∫mero, Cidade do Buraco, Estado do Buraco
    tem_dados_para_geo = endereco.get('rua') and numero_proximo and endereco.get('cidade_buraco') and endereco.get('estado_buraco')

    if geocoding_api_key and tem_dados_para_geo:
        print("\n‚úÖ Chave de Geocodifica√ß√£o e dados b√°sicos de endere√ßo completos encontrados.")
        print("‚è≥ Tentando gerar o link do Google Maps automaticamente a partir do endere√ßo...")
        tentou_geocodificar = True
        geo_resultado = geocodificar_endereco(
            endereco['rua'],
            numero_proximo,
            endereco['cidade_buraco'],
            endereco['estado_buraco'],
            geocoding_api_key
        )

        if 'erro' not in geo_resultado:
            geocodificacao_sucesso = True
            localizacao_exata_processada = {
                "tipo": "Geocodificada (API)", # Indica que veio da API
                "latitude": geo_resultado['latitude'],
                "longitude": geo_resultado['longitude'],
                "endereco_formatado_api": geo_resultado.get('endereco_formatado_api', ''),
                "google_maps_link_gerado": geo_resultado['google_maps_link_gerado']
            }
            print("\n--- ‚úÖ Localiza√ß√£o Obtida (via Geocodifica√ß√£o Autom√°tica) ---")
            print(f"Endere√ßo (API): {localizacao_exata_processada.get('endereco_formatado_api', 'N√£o dispon√≠vel')}")
            print(f"Coordenadas: {localizacao_exata_processada.get('latitude')}, {localizacao_exata_processada.get('longitude')}")
            print(f"Link Google Maps: {localizacao_exata_processada.get('google_maps_link_gerado', 'N√£o dispon√≠vel')}")
            print("---------------------------------------------------------")
            print("Esta √© a localiza√ß√£o que a API encontrou para o endere√ßo. Se n√£o for EXATA, por favor, forne√ßa-a manualmente na pr√≥xima etapa!")

        else: # Erro na geocodifica√ß√£o
            print(f"‚ùå Falha na Geocodifica√ß√£o autom√°tica: {geo_resultado['erro']}")
            motivo_falha_geo = f"Erro da API de Geocodifica√ß√£o: {geo_resultado.get('erro', 'Motivo desconhecido')}"

    elif geocoding_api_key and not tem_dados_para_geo:
         print("‚ö†Ô∏è AVISO: Chave de Geocodifica√ß√£o fornecida, mas dados de endere√ßo insuficientes (precisa de Rua, N√∫mero Pr√≥ximo, Cidade, Estado).")
         print("A Geocodifica√ß√£o autom√°tica N√ÉO ser√° tentada.")
         motivo_falha_geo = "Dados insuficientes para Geocodifica√ß√£o (requer Rua, N√∫mero, Cidade, Estado)."

    elif not geocoding_api_key:
         print("‚ö†Ô∏è AVISO: Chave de API de Geocodifica√ß√£o N√ÉO fornecida.")
         print("A Geocodifica√ß√£o autom√°tica N√ÉO ser√° tentada.")
         motivo_falha_geo = "Chave de API de Geocodifica√ß√£o n√£o fornecida."


    # Se a geocodifica√ß√£o N√ÉO FOI bem-sucedida OU N√ÉO FOI TENTADA, pedimos entrada manual
    # Usamos 'geocodificacao_sucesso' aqui. Se tentou mas falhou ou n√£o tentou, pedimos manual.
    if not geocodificacao_sucesso:
        print("\n--- ‚úçÔ∏è Fornecer Localiza√ß√£o Exata Manualmente (Alternativa ou Corre√ß√£o) ---")
        if motivo_falha_geo:
             print(f"(Motivo para entrada manual: {motivo_falha_geo})")

        print("‚û°Ô∏è Por favor, forne√ßa a localiza√ß√£o EXATA do buraco de forma manual:")
        print("   A MELHOR forma √© COPIAR AS COORDENADAS (Lat,Long) ou um LINK do Google Maps que as contenha.")
        print("   Sugest√£o: Abra o Google Maps, encontre o buraco, TOQUE/CLIQUE E SEGURE NO LOCAL PREOCUPANTE. As coordenadas ou um link aparecer√£o.")
        print("   Alternativamente, uma DESCRI√á√ÉO MUITO DETALHADA do local EXATO no mapa.")

        localizacao_manual_input = input("Insira COORDENADAS (Lat,Long), LINK do Maps com Coordenadas, OU DESCRI√á√ÉO DETALHADA: ").strip()

        while not localizacao_manual_input:
             print("‚ùó A localiza√ß√£o exata √© a b√∫ssola para o reparo! Por favor, forne√ßa COORDENADAS, LINK ou DESCRI√á√ÉO.")
             localizacao_manual_input = input("Insira COORDENADAS (Lat,Long), LINK do Maps com Coordenadas, OU DESCRI√á√ÉO DETALHADA: ").strip()

        # Tentar extrair coordenadas do input manual (reusando regex)
        lat: Optional[float] = None
        lon: Optional[float] = None
        tipo_manual_processado = "Descri√ß√£o Manual Detalhada"

        # Regex para tentar achar coordenadas em diferentes formatos (Lat,Long ou em links comuns)
        # Tenta cobrir "lat,long", "@lat,long" em links
        match_coords = re.search(r'(-?\d+\.?\d*)[,\s/]+(-?\d+\.?\d*)', localizacao_manual_input)
        if match_coords:
            try:
                teste_lat = float(match_coords.group(1))
                teste_lon = float(match_coords.group(2))
                # Valida√ß√£o b√°sica de faixa de coordenadas
                if -90 <= teste_lat <= 90 and -180 <= teste_lon <= 180:
                    lat = teste_lat
                    lon = teste_lon
                    tipo_manual_processado = "Coordenadas Fornecidas/Extra√≠das Manualmente"
                    print("‚úÖ Coordenadas v√°lidas detectadas no input manual! Navega√ß√£o calibrada.")
                else:
                    print("‚ö†Ô∏è Parece um formato de coordenadas, mas fora da faixa esperada. Tratando como descri√ß√£o. Rob√¥ confuso! üòÖ")
            except ValueError:
                print("‚ÑπÔ∏è Entrada manual n√£o parece ser coordenadas v√°lidas. Tratando como descri√ß√£o detalhada.")
            except Exception as e:
                 print(f"‚ÑπÔ∏è Ocorreu um erro ao tentar processar as coordenadas/link no input manual: {e}. Tratando como descri√ß√£o.")
        elif localizacao_manual_input.startswith("http"):
             print("‚ÑπÔ∏è Entrada manual √© um link. Tentando extrair coordenadas (sujeito a formato do link)...")
             # Regex mais focado em links Google Maps que EM GERAL cont√©m @lat,long
             match_maps_link = re.search(r'/@(-?\d+\.?\d*),(-?\d+\.?\d*)', localizacao_manual_input)
             if match_maps_link:
                 try:
                     teste_lat = float(match_maps_link.group(1))
                     teste_lon = float(match_maps_link.group(2))
                      # Valida√ß√£o b√°sica de faixa
                     if -90 <= teste_lat <= 90 and -180 <= teste_lon <= 180:
                         lat = teste_lat
                         lon = teste_lon
                         tipo_manual_processado = "Coordenadas Extra√≠das de Link (Manual)"
                         print("‚úÖ Coordenadas extra√≠das de link do Maps no input manual!")
                     else:
                         print("‚ö†Ô∏è Coordenadas extra√≠das do link no input manual fora da faixa esperada. Tratando como descri√ß√£o.")
                 except ValueError:
                    print("‚ÑπÔ∏è Valores no link n√£o parecem coordenadas v√°lidas. Tratando como descri√ß√£o.")
                 except Exception as e:
                      print(f"‚ÑπÔ∏è Ocorreu um erro ao tentar processar o link no input manual: {e}. Tratando como descri√ß√£o.")
             else:
                  print("‚ÑπÔ∏è N√£o foi poss√≠vel extrair coordenadas reconhec√≠veis do link fornecido manualmente.")
        else:
             print("‚ÑπÔ∏è Entrada manual n√£o detectada como coordenadas ou link. Tratando como descri√ß√£o detalhada.")


        # Armazenar o resultado do input manual no dicion√°rio de localiza√ß√£o processada
        if lat is not None and lon is not None:
            localizacao_exata_processada = {
                 "tipo": tipo_manual_processado,
                 "input_original": localizacao_manual_input,
                 "latitude": lat,
                 "longitude": lon,
                 "google_maps_link_gerado": f"https://www.google.com/maps/search/?api=1&query={lat},{lon}" # Gera link do Maps
            }
        else: # N√£o conseguiu extrair Lat/Long, armazena como descri√ß√£o
            localizacao_exata_processada = {
                 "tipo": "Descri√ß√£o Manual Detalhada",
                 "input_original": localizacao_manual_input,
                 "descricao_manual": localizacao_manual_input # A descri√ß√£o √© o input original
            }

        # Se houve uma tentativa de geocodifica√ß√£o autom√°tica que falhou, registra o motivo na entrada manual processada
        if tentou_geocodificar and not geocodificacao_sucesso:
             localizacao_exata_processada['motivo_falha_geocodificacao_anterior'] = motivo_falha_geo
        elif not geocoding_api_key:
             localizacao_exata_processada['motivo_falha_geocodificacao_anterior'] = "Chave de API de Geocodifica√ß√£o n√£o fornecida."
        elif not tem_dados_para_geo and geocoding_api_key: # Tinha chave mas n√£o dados suficientes
             localizacao_exata_processada['motivo_falha_geocodificacao_anterior'] = "Dados insuficientes para Geocodifica√ß√£o (Rua, N√∫mero, Cidade, Estado)."


    # --- üß† Entrada Principal para An√°lise de IA ---
    print("\n--- ‚úçÔ∏è Descreva o Buraco em Detalhes (Hora da IA Brilhar!) ---")
    print("Esta descri√ß√£o alimenta o c√©rebro da IA. Quanto mais rico em detalhes, melhor a an√°lise!")
    print("Fale sobre tamanho, profundidade, perigos, se tem √°gua, se √© antigo/novo, etc.")
    print("Pense nisso como um √°udio para um amigo explicando o problema na rua. üòâ")

    descricao_detalhada = input("Sua descri√ß√£o detalhada do buraco: ").strip()
    while not descricao_detalhada:
         print("‚ùó A descri√ß√£o √© a mat√©ria-prima da IA! N√£o deixe vazio, por favor.")
         descricao_detalhada = input("Sua descri√ß√£o detalhada do buraco: ").strip()


    # --- Nota sobre a limita√ß√£o de geolocaliza√ß√£o direta ---
    print("\n--- üí° Aviso Rob√≥tico Amig√°vel ---")
    print("Lembre-se: Eu, Krateras, moro nas nuvens do Google Colab. N√£o tenho acesso ao seu GPS local!")
    print("A precis√£o da localiza√ß√£o desta den√∫ncia depende das informa√ß√µes (Geocodifica√ß√£o ou Coordenadas/Descri√ß√£o Manual) que voc√™ me deu agora.")
    print("Agrade√ßo sua coopera√ß√£o geogr√°fica! üôè")
    print("------------------------------------------\n")


    return {
        "endereco": endereco, # Cont√©m rua, bairro, cidade_buraco, estado_buraco
        "cep_informado": cep_informado, # Vazio se a rua foi digitada manualmente
        "numero_proximo": numero_proximo,
        "lado_rua": lado_rua,
        "localizacao_exata_processada": localizacao_exata_processada, # Dicion√°rio detalhado da localiza√ß√£o PROCESSADA
        "descricao_detalhada": descricao_detalhada
    }

# --- üß† Fun√ß√µes de An√°lise Avan√ßada de IA (Google Gemini) ---
# Aqui o Google Gemini usa seus circuitos avan√ßados para entender o buraco.

def analisar_descricao_gemini(descricao: str, model: genai.GenerativeModel) -> Dict[str, Any]:
    """Utiliza o Gemini para analisar a descri√ß√£o detalhada do buraco e extrair insights estruturados."""
    if not model:
        return {"insights": "ü§ñ An√°lise de descri√ß√£o via IA indispon√≠vel (Motor Gemini offline)."}
    if not descricao or descricao.strip() == "":
         return {"insights": "üîç Sem descri√ß√£o fornecida para an√°lise de IA."}

    print("\nüß† Executando an√°lise profunda da descri√ß√£o do buraco com IA Gemini...")
    try:
        prompt = f"""
        Analise a seguinte descri√ß√£o DETALHADA de um buraco em uma rua. Seu objetivo √© extrair informa√ß√µes objetivas e insights CRUCIAIS para um sistema de den√∫ncias de reparo p√∫blico.
        Formate a sa√≠da como um texto claro, usando marcadores (-) ou t√≠tulos para cada categoria.
        Se uma categoria N√ÉO PUDER ser claramente mencionada ou inferida COM ALTA CONFIAN√áA a partir do texto, indique explicitamente "N√£o especificado/inferido na descri√ß√£o". Seja honesto sobre o que PODE ser extra√≠do.

        Descri√ß√£o do Buraco: "{descricao}"

        Categorias para Extrair/Inferir da Descri√ß√£o:
        - Severidade/Tamanho Estimado (Baseado na descri√ß√£o): [Ex: Pequeno, M√©dio, Grande, Enorme, Cr√≠tico. Use termos comparativos se presentes, ex: "do tamanho de uma roda de carro".]
        - Profundidade Estimada: [Ex: Raso, Fundo, Muito Fundo. Termos como "cabe um pneu" indicam profundidade.]
        - Presen√ßa de √Ågua/Alagamento: [Sim/N√£o/N√£o mencionado, se acumula √°gua, vira piscina.]
        - Perigos Potenciais e Impactos Mencionados: [Liste riscos espec√≠ficos citados ou implicados (ex: risco de acidente de carro/moto/bike, perigo para pedestres, causa danos a ve√≠culos - pneu furado, suspens√£o, roda -, dificuldade de desviar, risco de queda, perigo √† noite/chuva). Seja espec√≠fico.]
        - Contexto Adicional Relevante do Local/Hist√≥rico: [Problema recorrente/antigo/novo, perto de local importante (escola, hospital, com√©rcio), em via movimentada, em curva, na esquina, na subida/descida, pouca ilumina√ß√£o.]
        - Sugest√µes de A√ß√£o/Recursos Mencionados pelo Denunciante: [Se o usu√°rio sugere o que fazer (tapa-buraco, recapeamento, sinalizar) ou causas percebidas.]
        - Identificadores Visuais Adicionais (se descritos): [Coisas √∫nicas pr√≥ximas que ajudam a achar o buraco (poste X, √°rvore Y, em frente a Z).]
        - Palavras-chave Principais: [Liste 3-7 palavras-chave que capturem a ess√™ncia da den√∫ncia e o problema principal.]

        Formate a resposta de forma limpa e estruturada.
        """
        safety_settings = [ # Mantido em NONE para permitir discuss√£o de perigos/riscos
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        response = model.generate_content(prompt, safety_settings=safety_settings)

        # Verifica se a resposta foi bloqueada por seguran√ßa ou n√£o tem conte√∫do
        if not hasattr(response, 'candidates') or not response.candidates:
             block_reason = "Desconhecido"
             if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason'):
                 block_reason = response.prompt_feedback.block_reason.name
             print(f"‚ùå An√°lise de descri√ß√£o bloqueada pelos protocolos de seguran√ßa do Gemini. Motivo: {block_reason}")
             return {"insights": f"‚ùå An√°lise de descri√ß√£o bloqueada pelo filtro de seguran√ßa do Gemini. Motivo: {block_reason}"}


        # Extrai o texto da resposta
        return {"insights": response.text.strip()}

    except Exception as e:
        print(f"‚ùå ERRO na an√°lise da descri√ß√£o com Gemini: {e}. O C√©rebro da IA deu tela azul! üòµ‚Äçüí´")
        return {"insights": f"‚ùå Erro ao analisar a descri√ß√£o com IA: {e}"}


def categorizar_urgencia_gemini(dados_denuncia: Dict[str, Any], insights_ia: Dict[str, Any], model: genai.GenerativeModel) -> Dict[str, Any]:
    """Utiliza o Gemini para sugerir uma categoria de urg√™ncia com base nos dados e insights."""
    if not model:
        return {"urgencia_ia": "ü§ñ Sugest√£o de urg√™ncia via IA indispon√≠vel (Motor Gemini offline)."}

    print("\nüß† Calculando o N√≠vel de Prioridade Rob√≥tica para esta den√∫ncia...")
    try:
        descricao = dados_denuncia.get('descricao_detalhada', 'Sem descri√ß√£o.')
        insights_texto = insights_ia.get('insights', 'An√°lise de insights n√£o dispon√≠vel.')
        localizacao_exata = dados_denuncia.get('localizacao_exata_processada', {})
        tipo_loc = localizacao_exata.get('tipo', 'N√£o informada')
        input_original_loc = localizacao_exata.get('input_original', 'N√£o informado.')


        # Formata a string de localiza√ß√£o para dar contexto √† IA
        loc_contexto = f"Localiza√ß√£o informada: Tipo: {tipo_loc}. Detalhes originais: '{input_original_loc}'."
        if tipo_loc in ['Coordenadas Fornecidas/Extra√≠das Manualmente', 'Geocodificada (API)', 'Coordenadas Extra√≠das de Link (Manual)']:
            lat = localizacao_exata.get('latitude')
            lon = localizacao_exata.get('longitude')
            loc_contexto += f" Coordenadas: {lat}, {lon}. Link gerado: {localizacao_exata.get('google_maps_link_gerado', 'N√£o dispon√≠vel')}."
        elif localizacao_exata.get('motivo_falha_geocodificacao_anterior'):
             loc_contexto += f" (Nota: Tentativa de Geocodifica√ß√£o autom√°tica falhou/n√£o tentada: {localizacao_exata.get('motivo_falha_geocodificacao_anterior', 'Motivo desconhecido')})"


        prompt = f"""
        Com base nas informa√ß√µes da den√∫ncia e nos insights extra√≠dos pela an√°lise anterior, sugira a MELHOR categoria de urg√™ncia para o reparo deste buraco.
        Considere a severidade/tamanho, profundidade, PERIGOS POTENCIAIS e impactos mencionados, e qualquer CONTEXTO ADICIONAL relevante (como ser recorrente, em √°rea de alto tr√°fego/risco, perto de local importante).

        Escolha UMA Categoria de Urg√™ncia entre estas:
        - Urg√™ncia Baixa: Buraco pequeno, sem perigo aparente, em local de baixo tr√°fego. Principalmente est√©tico ou pequeno inc√¥modo.
        - Urg√™ncia M√©dia: Tamanho razo√°vel, pode causar leve inc√¥modo ou dano menor (ex: pneu furado leve), em via secund√°ria ou com tr√°fego moderado. Requer reparo em prazo razo√°vel.
        - Urg√™ncia Alta: Buraco grande, profundo, perigo CLARO e/ou frequente (risco de acidente mais s√©rio, dano significativo a ve√≠culo, perigo para motos/bikes/pedestres), em via movimentada ou √°rea de risco (escola, hospital). Requer aten√ß√£o R√ÅPIDA, possivelmente em poucos dias.
        - Urg√™ncia Imediata/Cr√≠tica: Buraco ENORME/muito profundo que causa acidentes CONSTANTES ou representa risco GRAVE e iminente a ve√≠culos ou pessoas (ex: cratera na pista principal), afeta severamente a fluidez ou acessibilidade. Requer interven√ß√£o de EMERG√äNCIA (horas/poucas horas).

        Informa√ß√µes Relevantes da Den√∫ncia:
        Localiza√ß√£o B√°sica: Rua {dados_denuncia.get('endereco', {}).get('rua', 'N√£o informada')}, N√∫mero Pr√≥ximo/Refer√™ncia: {dados_denuncia.get('numero_proximo', 'N√£o informado')}, Lado: {dados_denuncia.get('lado_rua', 'N√£o informado')}, Cidade: {dados_denuncia.get('endereco', {}).get('cidade_buraco', 'N√£o informada')}, Estado: {dados_denuncia.get('endereco', {}).get('estado_buraco', 'N√£o informado')}.
        {loc_contexto}
        Descri√ß√£o Original do Denunciante: "{descricao}"
        Insights Extra√≠dos pela An√°lise de IA:
        {insights_texto}

        Com base nestes dados, qual categoria de urg√™ncia voc√™ sugere? Forne√ßa APENAS a categoria (ex: "Urg√™ncia Alta") e uma breve JUSTIFICATIVA (m√°ximo 2 frases) explicando POR QUE essa categoria foi sugerida, citando elementos da descri√ß√£o ou insights.

        Formato de sa√≠da (muito importante seguir este formato):
        Categoria Sugerida: [Categoria Escolhida]
        Justificativa: [Justificativa Breve]
        """
        safety_settings = [ # Mantido em NONE para permitir discuss√£o de perigos/riscos
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        response = model.generate_content(prompt, safety_settings=safety_settings)

        if not hasattr(response, 'candidates') or not response.candidates:
             block_reason = "Desconhecido"
             if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason'):
                 block_reason = response.prompt_feedback.block_reason.name
             print(f"‚ùå Sugest√£o de urg√™ncia bloqueada pelos protocolos de seguran√ßa do Gemini. Motivo: {block_reason}")
             return {"urgencia_ia": f"‚ùå Sugest√£o de urg√™ncia bloqueada. Motivo: {block_reason}"}


        return {"urgencia_ia": response.text.strip()}
    except Exception as e:
        print(f"‚ùå ERRO na sugest√£o de urg√™ncia com Gemini: {e}. A IA n√£o conseguiu classificar a prioridade! ü§ñüíî")
        return {"urgencia_ia": f"‚ùå Erro ao sugerir urg√™ncia com IA: {e}"}

def sugerir_causa_e_acao_gemini(dados_denuncia: Dict[str, Any], insights_ia: Dict[str, Any], model: genai.GenerativeModel) -> Dict[str, Any]:
    """Utiliza o Gemini para sugerir poss√≠veis causas do buraco e a√ß√µes de reparo com base nos dados e insights."""
    if not model:
        return {"sugestao_acao_ia": "ü§ñ Sugest√µes de causa/a√ß√£o via IA indispon√≠veis (Motor Gemini offline)."}

    print("\nüß† IA est√° pensando... Qual pode ser a causa e a melhor a√ß√£o para este buraco?")
    try:
        descricao = dados_denuncia.get('descricao_detalhada', 'Sem descri√ß√£o.')
        insights_texto = insights_ia.get('insights', 'An√°lise de insights n√£o dispon√≠vel.')

        prompt = f"""
        Com base na descri√ß√£o fornecida pelo denunciante e nos insights extra√≠dos pela an√°lise de IA, tente sugerir:
        1. Uma ou duas P√ìSSIVEIS CAUSAS para a forma√ß√£o deste buraco espec√≠fico (ex: chuva forte recente, desgaste do asfalto pelo tempo/tr√°fego, problema na drenagem subterr√¢nea, afundamento devido a reparo anterior, obra mal feita na regi√£o). Baseie-se no contexto (se recorrente, se choveu, etc).
        2. Sugest√µes de TIPOS DE A√á√ÉO ou REPARO mais adequados ou necess√°rios para resolver este problema (ex: simples tapa-buraco, recapeamento da se√ß√£o, inspe√ß√£o de drenagem, sinaliza√ß√£o de emerg√™ncia, interdi√ß√£o parcial da via). Baseie-se na severidade e perigos.
        Baseie suas sugest√µes EXCLUSIVAMENTE nas informa√ß√µes fornecidas na descri√ß√£o e nos insights. Se a descri√ß√£o n√£o der pistas suficientes, indique "N√£o especificado/inferido na descri√ß√£o". Seja l√≥gico e pr√°tico.

        Informa√ß√µes Relevantes da Den√∫ncia:
        Descri√ß√£o Original do Buraco: "{descricao}"
        Insights Extra√≠dos pela An√°lise de IA:
        {insights_texto}

        Formato de sa√≠da:
        Poss√≠veis Causas Sugeridas: [Lista de causas sugeridas baseadas na descri√ß√£o ou 'N√£o especificado/inferido']
        Sugest√µes de A√ß√£o/Reparo Sugeridas: [Lista de a√ß√µes sugeridas baseadas na descri√ß√£o/insights ou 'N√£o especificado/inferido']
        """
        safety_settings = [ # Mantido em NONE
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        response = model.generate_content(prompt, safety_settings=safety_settings)

        if not hasattr(response, 'candidates') or not response.candidates:
             block_reason = "Desconhecido"
             if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason'):
                 block_reason = response.prompt_feedback.block_reason.name
             print(f"‚ùå Sugest√£o de causa/a√ß√£o bloqueada pelos protocolos de seguran√ßa do Gemini. Motivo: {block_reason}")
             return {"sugestao_acao_ia": f"‚ùå Sugest√£o de causa/a√ß√£o bloqueada. Motivo: {block_reason}"}

        return {"sugestao_acao_ia": response.text.strip()}

    except Exception as e:
        print(f"‚ùå ERRO na sugest√£o de causa/a√ß√£o com Gemini: {e}. A IA n√£o conseguiu diagnosticar o problema!")
        return {"sugestao_acao_ia": f"‚ùå Erro ao sugerir causa/a√ß√£o com IA: {e}"}


def gerar_resumo_completo_gemini(dados_denuncia_completa: Dict[str, Any], model: genai.GenerativeModel) -> Dict[str, Any]:
    """Utiliza o Gemini para gerar um resumo narrativo inteligente da den√∫ncia completa."""
    if not model:
        return {"resumo_ia": "ü§ñ Resumo inteligente via IA indispon√≠vel (Motor Gemini offline)."}

    print("\nüß† Compilando o Relat√≥rio Final Rob√≥tico e Inteligente com IA Gemini...")
    try:
        denunciante = dados_denuncia_completa.get('denunciante', {})
        buraco = dados_denuncia_completa.get('buraco', {}) # Dados brutos do buraco
        endereco = buraco.get('endereco', {}) # Endere√ßo b√°sico dentro dos dados brutos
        localizacao_exata = dados_denuncia_completa.get('localizacao_exata_processada', {}) # Usa a chave processada no n√≠vel superior
        insights_ia = dados_denuncia_completa.get('insights_ia', {}).get('insights', 'An√°lise da descri√ß√£o n√£o dispon√≠vel ou com erro.')
        urgencia_ia = dados_denuncia_completa.get('urgencia_ia', {}).get('urgencia_ia', 'Sugest√£o de urg√™ncia n√£o dispon√≠vel ou com erro.')
        sugestao_acao_ia = dados_denuncia_completa.get('sugestao_acao_ia', {}).get('sugestao_acao_ia', 'Sugest√µes de causa/a√ß√£o n√£o dispon√≠veis ou com erro.')


        # Formatar a string de localiza√ß√£o para o resumo
        loc_info_resumo = "Localiza√ß√£o exata n√£o especificada ou processada."
        tipo_loc_processada = localizacao_exata.get('tipo', 'N√£o informada')

        if tipo_loc_processada in ['Coordenadas Fornecidas/Extra√≠das Manualmente', 'Geocodificada (API)', 'Coordenadas Extra√≠das de Link (Manual)']:
             lat = localizacao_exata.get('latitude')
             lon = localizacao_exata.get('longitude')
             link_gerado = localizacao_exata.get('google_maps_link_gerado', 'N√£o dispon√≠vel')
             loc_info_resumo = f"Localiza√ß√£o: Coordenadas {lat}, {lon} (Obtida via: {tipo_loc_processada.replace(' (API)', ' API').replace('Manual', 'Manual').replace('Fornecidas/Extra√≠das', 'Manual')}). Link Google Maps: {link_gerado}."
             if localizacao_exata.get('input_original'):
                 loc_info_resumo += f" (Input original: '{localizacao_exata.get('input_original')}')"

        elif tipo_loc_processada == 'Descri√ß√£o Manual Detalhada':
             loc_info_resumo = f"Localiza√ß√£o via descri√ß√£o manual detalhada: '{localizacao_exata.get('descricao_manual', 'N√£o informada')}'. (Input original: '{localizacao_exata.get('input_original', 'N√£o informado')}')"

        elif localizacao_exata.get('input_original') and tipo_loc_processada == 'N√£o informada': # Se n√£o identificamos o tipo mas temos o input original
             loc_info_resumo = f"Localiza√ß√£o informada (tipo n√£o detectado): '{localizacao_exata.get('input_original')}'."

        if localizacao_exata.get('motivo_falha_geocodificacao_anterior'):
             loc_info_resumo += f" (Nota: Geocodifica√ß√£o autom√°tica falhou/n√£o tentada: {localizacao_exata.get('motivo_falha_geocodificacao_anterior')})"


        prompt = f"""
        Gere um resumo narrativo conciso (m√°ximo 8-10 frases) para a seguinte den√∫ncia de buraco no aplicativo Krateras.
        Este resumo deve ser formal, objetivo e √∫til para equipes de manuten√ß√£o ou gest√£o p√∫blica.
        Combine os dados estruturados, a localiza√ß√£o exata processada e os insights das an√°lises de IA.

        Inclua:
        - Quem denunciou (Nome, Cidade de Resid√™ncia).
        - Onde est√° o buraco (Rua, N√∫mero Pr√≥ximo/Refer√™ncia, Bairro, Cidade do Buraco, Estado do Buraco, CEP se dispon√≠vel).
        - A localiza√ß√£o EXATA (mencione como foi obtida - Geocodificada, Coordenadas Manual, Descri√ß√£o Manual - e inclua os dados - Coordenadas/Link Gerado ou Descri√ß√£o Manual).
        - O lado da rua.
        - Os principais pontos da An√°lise Detalhada de IA sobre o buraco (Severidade/Tamanho, Perigos Potenciais, Contexto Relevante).
        - A SUGEST√ÉO de Categoria de Urg√™ncia pela IA e sua Justificativa.
        - As SUGEST√ïES de POSS√çVEIS CAUSAS e TIPOS DE A√á√ÉO/REPARO sugeridas pela IA (se dispon√≠veis).

        Dados da Den√∫ncia:
        Denunciante: {denunciante.get('nome', 'N√£o informado')}, de {denunciante.get('cidade_residencia', 'N√£o informada')}.
        Endere√ßo do Buraco: Rua {endereco.get('rua', 'N√£o informada')}, N¬∫ Pr√≥ximo: {buraco.get('numero_proximo', 'N√£o informado')}. Bairro: {endereco.get('bairro', 'N√£o informado')}. Cidade: {endereco.get('cidade_buraco', 'N√£o informada')}, Estado: {endereco.get('estado_buraco', 'N√£o informado')}. CEP: {buraco.get('cep_informado', 'N√£o informado')}.
        Lado da Rua: {buraco.get('lado_rua', 'N√£o informado')}.
        Localiza√ß√£o Exata Coletada: {loc_info_resumo}
        Descri√ß√£o Original: "{buraco.get('descricao_detalhada', 'N√£o fornecida.')}"

        Insights da An√°lise Detalhada de IA:
        {insights_ia}

        Sugest√£o de Urg√™ncia pela IA:
        {urgencia_ia}

        Sugest√µes de Causa e A√ß√£o pela IA:
        {sugestao_acao_ia}


        Gere o resumo em portugu√™s. Comece com "Relat√≥rio Krateras: Den√∫ncia de buraco..." ou algo similar. Use linguagem clara e direta.
        """
        safety_settings = [ # Mantido em NONE para permitir discuss√£o de perigos/riscos
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        response = model.generate_content(prompt, safety_settings=safety_settings)

        if not hasattr(response, 'candidates') or not response.candidates:
             block_reason = "Desconhecido"
             if hasattr(response, 'prompt_feedback') and hasattr(response.prompt_feedback, 'block_reason'):
                 block_reason = response.prompt_feedback.block_reason.name
             print(f"‚ùå Gera√ß√£o de resumo bloqueada pelos protocolos de seguran√ßa do Gemini. Motivo: {block_reason}")
             return {"resumo_ia": f"‚ùå Gera√ß√£o de resumo bloqueada. Motivo: {block_reason}"}

        return {"resumo_ia": response.text.strip()}
    except Exception as e:
        print(f"‚ùå ERRO na gera√ß√£o do resumo com Gemini: {e}. O compilador de relat√≥rio teve um bug!")
        return {"resumo_ia": f"‚ùå Erro ao gerar resumo completo com IA: {e}"}


# --- üìä Fun√ß√µes de Sa√≠da Final ---
# Apresenta o relat√≥rio completo com dados coletados e an√°lises de IA.

def exibir_resumo_denuncia(dados_completos: Dict[str, Any]):
    """Exibe um resumo formatado da den√∫ncia completa, incluindo todas as an√°lises de IA."""
    denunciante = dados_completos.get('denunciante', {})
    buraco = dados_completos.get('buraco', {})
    endereco = buraco.get('endereco', {})
    localizacao_exata = dados_completos.get('localizacao_exata_processada', {}) # Usa a chave processada
    insights_ia = dados_completos.get('insights_ia', {})
    urgencia_ia = dados_completos.get('urgencia_ia', {})
    sugestao_acao_ia = dados_completos.get('sugestao_acao_ia', {}) # Nova chave
    resumo_ia = dados_completos.get('resumo_ia', {})

    print("\n" + "="*60)
    print("         üìä RELAT√ìRIO FINAL DA DEN√öNCIA KRATERAS üìä")
    print("="*60)

    print("\n--- üë§ Dados do Denunciante ---")
    print(f"Nome: {denunciante.get('nome', 'N√£o informado')}")
    print(f"Idade: {denunciante.get('idade', 'N√£o informado')}")
    print(f"Cidade de Resid√™ncia: {denunciante.get('cidade_residencia', 'N√£o informada')}") # Chave atualizada

    print("\n--- üöß Dados do Buraco ---")
    print(f"Rua: {endereco.get('rua', 'N√£o informada')}")
    if buraco.get('numero_proximo'):
        print(f"Refer√™ncia/N√∫mero Pr√≥ximo: {buraco.get('numero_proximo')}")
    if endereco.get('bairro'):
        print(f"Bairro: {endereco.get('bairro')}")
    if endereco.get('cidade_buraco'): # Chave atualizada
         print(f"Cidade do Buraco: {endereco.get('cidade_buraco')}")
    if endereco.get('estado_buraco'): # Chave atualizada
        print(f"Estado do Buraco: {endereco.get('estado_buraco')}")
    if buraco.get('cep_informado'):
        print(f"CEP Informado: {buraco.get('cep_informado')}")

    print(f"Lado da Rua: {buraco.get('lado_rua', 'N√£o informado')}")


    print("\n--- üìç Localiza√ß√£o Exata ---")
    tipo_loc = localizacao_exata.get('tipo', 'N√£o informada')
    print(f"Tipo de Coleta: {tipo_loc}")

    if tipo_loc in ['Coordenadas Fornecidas/Extra√≠das Manualmente', 'Geocodificada (API)', 'Coordenadas Extra√≠das de Link (Manual)']:
        print(f"Coordenadas: {localizacao_exata.get('latitude')}, {localizacao_exata.get('longitude')}")
        if localizacao_exata.get('google_maps_link_gerado'):
            print(f"Link Google Maps Gerado: {localizacao_exata.get('google_maps_link_gerado')}")
        if localizacao_exata.get('endereco_formatado_api'):
             print(f"Endere√ßo Formatado (API): {localizacao_exata.get('endereco_formatado_api')}")
        print(f"(Input Original: '{localizacao_exata.get('input_original', 'N√£o informado')}')")

    elif tipo_loc == 'Descri√ß√£o Manual Detalhada':
        print(f"Descri√ß√£o Manual: {localizacao_exata.get('descricao_manual', 'N√£o informada')}")
        print(f"(Input Original: '{localizacao_exata.get('input_original', 'N√£o informado')}')")

    else:
        print("Localiza√ß√£o exata n√£o coletada de forma estruturada.")

    # Inclui motivo da falha na geocodifica√ß√£o se aplic√°vel
    if localizacao_exata.get('motivo_falha_geocodificacao_anterior'):
         print(f"‚ÑπÔ∏è Nota: N√£o foi poss√≠vel obter a localiza√ß√£o exata via Geocodifica√ß√£o autom√°tica. Motivo: {localizacao_exata.get('motivo_falha_geocodificacao_anterior')}")


    print("\n--- üìù Descri√ß√£o Original do Denunciante ---")
    print(buraco.get('descricao_detalhada', 'Nenhuma descri√ß√£o fornecida.'))


    print("\n--- üß† An√°lise Detalhada da Descri√ß√£o (IA Gemini) ---")
    print(insights_ia.get('insights', 'An√°lise n√£o realizada ou com erro.'))


    print("\n--- üö¶ Sugest√£o de Urg√™ncia (IA Gemini) ---")
    print(urgencia_ia.get('urgencia_ia', 'Sugest√£o de urg√™ncia n√£o gerada ou com erro.'))


    print("\n--- üõ†Ô∏è Sugest√µes de Causa e A√ß√£o (IA Gemini) ---")
    print(sugestao_acao_ia.get('sugestao_acao_ia', 'Sugest√µes n√£o geradas ou com erro.')) # Nova exibi√ß√£o


    print("\n--- üìú Resumo Narrativo Inteligente (IA Gemini) ---")
    print(resumo_ia.get('resumo_ia', 'Resumo n√£o gerado ou com erro.'))


    print("\n" + "="*60)
    print("        ‚úÖ MISS√ÉO KRATERAS CONCLU√çDA! RELAT√ìRIO GERADO. ‚úÖ")
    print("="*60)
    print("\nEsperamos que este relat√≥rio ajude a consertar o buraco!")


# --- üöÄ Fun√ß√£o Principal: O Orquestrador ---

def main():
    # 1. Instalar depend√™ncias (executado no in√≠cio do script)

    # 2. Obter chaves de API (agora tenta Segredos para ambas)
    gemini_api_key, geocoding_api_key = get_api_keys()

    # 3. Inicializar Google Gemini
    gemini_model = init_gemini(gemini_api_key)

    # 4. Coletar dados do denunciante
    denunciante = coletar_dados_denunciante()

    # 5. Coletar dados do buraco (passa a chave de geocodifica√ß√£o opcional)
    # Esta fun√ß√£o retorna todos os dados brutos do buraco MAIS a localiza√ß√£o processada.
    buraco_data = coletar_dados_buraco(geocoding_api_key)

    # Estrutura completa da den√∫ncia. Move a localiza√ß√£o processada para o n√≠vel superior.
    denuncia_completa: Dict[str, Any] = {
        "denunciante": denunciante,
        "buraco": {k: v for k, v in buraco_data.items() if k != 'localizacao_exata_processada'}, # Copia tudo exceto a localiza√ß√£o processada
        "localizacao_exata_processada": buraco_data.get('localizacao_exata_processada') # Adiciona a localiza√ß√£o processada no n√≠vel superior
    }


    # 6. Rodar an√°lises de IA (se o modelo Gemini foi inicializado)
    if gemini_model:
        # An√°lise da descri√ß√£o
        insights = analisar_descricao_gemini(buraco_data.get('descricao_detalhada', ''), gemini_model)
        denuncia_completa['insights_ia'] = insights

        # Sugest√£o de urg√™ncia (usa dados do buraco e insights)
        # Passa buraco_data (que cont√©m os dados b√°sicos do buraco) E os insights_ia para dar contexto √† IA
        urgencia = categorizar_urgencia_gemini(buraco_data, denuncia_completa['insights_ia'], gemini_model)
        denuncia_completa['urgencia_ia'] = urgencia

        # Sugest√£o de causa e a√ß√£o (usa dados do buraco e insights)
        # Passa buraco_data E os insights_ia para dar contexto √† IA
        sugestao_acao = sugerir_causa_e_acao_gemini(buraco_data, denuncia_completa['insights_ia'], gemini_model)
        denuncia_completa['sugestao_acao_ia'] = sugestao_acao


        # Gera√ß√£o do resumo (usa todos os dados coletados e resultados da IA)
        # Passa a denuncia_completa completa que agora tem todos os dados + resultados das outras IAs
        resumo_ia = gerar_resumo_completo_gemini(denuncia_completa, gemini_model)
        denuncia_completa['resumo_ia'] = resumo_ia
    else:
         print("\n‚ö†Ô∏è Funcionalidades de An√°lise e Resumo da IA n√£o executadas (Gemini n√£o configurado).")
         denuncia_completa['insights_ia'] = {"insights": "An√°lise de descri√ß√£o via IA indispon√≠vel."}
         denuncia_completa['urgencia_ia'] = {"urgencia_ia": "Sugest√£o de urg√™ncia via IA indispon√≠vel."}
         denuncia_completa['sugestao_acao_ia'] = {"sugestao_acao_ia": "Sugest√µes de causa/a√ß√£o via IA indispon√≠veis."}
         denuncia_completa['resumo_ia'] = {"resumo_ia": "Resumo completo via IA indispon√≠vel."}


    # 7. Exibir o relat√≥rio completo
    exibir_resumo_denuncia(denuncia_completa)

    # 8. Ponto para salvar os dados (opcional)
    # Os dados completos da den√∫ncia est√£o no dicion√°rio `denuncia_completa`.
    # Voc√™ pode salv√°-los em um arquivo JSON, Google Sheets, etc.
    # print("\nüîå Dados brutos da den√∫ncia (formato JSON):")
    # print(json.dumps(denuncia_completa, indent=4, ensure_ascii=False))
    # try:
    #     with open("denuncia_krateras.json", "w", encoding='utf-8') as f:
    #         json.dump(denuncia_completa, f, indent=4, ensure_ascii=False)
    #     print("\nüíæ Dados da den√∫ncia salvos em 'denuncia_krateras.json' no ambiente do Colab.")
    # except Exception as e:
    #     print(f"\n‚ùå ERRO ao tentar salvar os dados em arquivo: {e}")


if __name__ == "__main__":
    main()